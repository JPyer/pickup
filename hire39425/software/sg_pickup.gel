/****************************************************************************/
/*                                                                          */
/*              General Extension Language                                  */
/*              通用扩展语言文件                                            */
/*                                                                          */
/*              2014年08月26日                                              */
/*                                                                          */
/****************************************************************************/
// 2014/12/24 删除管脚复用配置
#define PLL0_BASE       0x01C11000                              /*SYSTEM PLL BASE ADDRESS*/
#define PLL0_PID        *(unsigned int*) (PLL0_BASE + 0x00)     /*PID*/
#define PLL0_RSTYPE     *(unsigned int*) (PLL0_BASE + 0xE4)     /*Reset Type status Reg*/
#define PLL0_PLLCTL     *(unsigned int*) (PLL0_BASE + 0x100)    /*PLL Control Register*/
#define PLL0_OCSEL      *(unsigned int*) (PLL0_BASE + 0x104)    /*OBSCLK Select Register*/
#define PLL0_SECCTL     *(unsigned int*) (PLL0_BASE + 0x108)    /*PLL Secondary Control Register*/
#define PLL0_PLLM       *(unsigned int*) (PLL0_BASE + 0x110)    /*PLL Multiplier*/
#define PLL0_PREDIV     *(unsigned int*) (PLL0_BASE + 0x114)    /*Pre divider*/
#define PLL0_PLLDIV1    *(unsigned int*) (PLL0_BASE + 0x118)    /*Divider-1*/
#define PLL0_PLLDIV2    *(unsigned int*) (PLL0_BASE + 0x11C)    /*Divider-2*/
#define PLL0_PLLDIV3    *(unsigned int*) (PLL0_BASE + 0x120)    /*Divider-3*/
#define PLL0_OSCDIV1    *(unsigned int*) (PLL0_BASE + 0x124)    /*Oscilator Divider*/
#define PLL0_POSTDIV    *(unsigned int*) (PLL0_BASE + 0x128)    /*Post Divider*/
#define PLL0_BPDIV      *(unsigned int*) (PLL0_BASE + 0x12C)    /*Bypass Divider*/
#define PLL0_WAKEUP     *(unsigned int*) (PLL0_BASE + 0x130)    /*Wakeup Reg*/
#define PLL0_PLLCMD     *(unsigned int*) (PLL0_BASE + 0x138)    /*Command Reg*/
#define PLL0_PLLSTAT    *(unsigned int*) (PLL0_BASE + 0x13C)    /*Status Reg*/
#define PLL0_ALNCTL     *(unsigned int*) (PLL0_BASE + 0x140)    /*Clock Align Control Reg*/
#define PLL0_DCHANGE    *(unsigned int*) (PLL0_BASE + 0x144)    /*PLLDIV Ratio Chnage status*/
#define PLL0_CKEN       *(unsigned int*) (PLL0_BASE + 0x148)    /*Clock Enable Reg*/
#define PLL0_CKSTAT     *(unsigned int*) (PLL0_BASE + 0x14C)    /*Clock Status Reg*/
#define PLL0_SYSTAT     *(unsigned int*) (PLL0_BASE + 0x150)    /*Sysclk status reg*/
#define PLL0_PLLDIV4    *(unsigned int*) (PLL0_BASE + 0x160)    /*Divider 4*/
#define PLL0_PLLDIV5    *(unsigned int*) (PLL0_BASE + 0x164)    /*Divider 5*/
#define PLL0_PLLDIV6    *(unsigned int*) (PLL0_BASE + 0x168)    /*Divider 6*/
#define PLL0_PLLDIV7    *(unsigned int*) (PLL0_BASE + 0x16C)    /*Divider 7*/
#define PLL0_PLLDIV8    *(unsigned int*) (PLL0_BASE + 0x170)    /*Divider 8*/
#define PLL0_PLLDIV9    *(unsigned int*) (PLL0_BASE + 0x174)    /*Divider 9*/
#define PLL0_PLLDIV10   *(unsigned int*) (PLL0_BASE + 0x178)    /*Divider 10*/
#define PLL0_PLLDIV11   *(unsigned int*) (PLL0_BASE + 0x17C)    /*Divider 11*/
#define PLL0_PLLDIV12   *(unsigned int*) (PLL0_BASE + 0x180)    /*Divider 12*/
#define PLL0_PLLDIV13   *(unsigned int*) (PLL0_BASE + 0x184)    /*Divider 13*/
#define PLL0_PLLDIV14   *(unsigned int*) (PLL0_BASE + 0x188)    /*Divider 14*/
#define PLL0_PLLDIV15   *(unsigned int*) (PLL0_BASE + 0x18C)    /*Divider 15*/
#define PLL0_PLLDIV16   *(unsigned int*) (PLL0_BASE + 0x190)    /*Divider 16*/

#define PLL1_BASE       0x01E1A000                              /*SYSTEM PLL1 BASE ADDRESS*/
#define PLL1_PID        *(unsigned int*) (PLL1_BASE + 0x00)     /*PID*/
#define PLL1_RSTYPE     *(unsigned int*) (PLL1_BASE + 0xE4)     /*Reset Type status Reg*/
#define PLL1_PLLCTL     *(unsigned int*) (PLL1_BASE + 0x100)    /*PLL Control Register*/
#define PLL1_OCSEL      *(unsigned int*) (PLL1_BASE + 0x104)    /*OBSCLK Select Register*/
#define PLL1_SECCTL     *(unsigned int*) (PLL1_BASE + 0x108)    /*PLL Secondary Control Register*/
#define PLL1_PLLM       *(unsigned int*) (PLL1_BASE + 0x110)    /*PLL Multiplier*/
#define PLL1_PREDIV     *(unsigned int*) (PLL1_BASE + 0x114)    /*Pre divider*/
#define PLL1_PLLDIV1    *(unsigned int*) (PLL1_BASE + 0x118)    /*Divider-1*/
#define PLL1_PLLDIV2    *(unsigned int*) (PLL1_BASE + 0x11C)    /*Divider-2*/
#define PLL1_PLLDIV3    *(unsigned int*) (PLL1_BASE + 0x120)    /*Divider-3*/
#define PLL1_OSCDIV1    *(unsigned int*) (PLL1_BASE + 0x124)    /*Oscilator Divider*/
#define PLL1_POSTDIV    *(unsigned int*) (PLL1_BASE + 0x128)    /*Post Divider*/
#define PLL1_BPDIV      *(unsigned int*) (PLL1_BASE + 0x12C)    /*Bypass Divider*/
#define PLL1_WAKEUP     *(unsigned int*) (PLL1_BASE + 0x130)    /*Wakeup Reg*/
#define PLL1_PLLCMD     *(unsigned int*) (PLL1_BASE + 0x138)    /*Command Reg*/
#define PLL1_PLLSTAT    *(unsigned int*) (PLL1_BASE + 0x13C)    /*Status Reg*/
#define PLL1_ALNCTL     *(unsigned int*) (PLL1_BASE + 0x140)    /*Clock Align Control Reg*/
#define PLL1_DCHANGE    *(unsigned int*) (PLL1_BASE + 0x144)    /*PLLDIV Ratio Chnage status*/
#define PLL1_CKEN       *(unsigned int*) (PLL1_BASE + 0x148)    /*Clock Enable Reg*/
#define PLL1_CKSTAT     *(unsigned int*) (PLL1_BASE + 0x14C)    /*Clock Status Reg*/
#define PLL1_SYSTAT     *(unsigned int*) (PLL1_BASE + 0x150)    /*Sysclk status reg*/
#define PLL1_PLLDIV4    *(unsigned int*) (PLL1_BASE + 0x160)    /*Divider 4*/
#define PLL1_PLLDIV5    *(unsigned int*) (PLL1_BASE + 0x164)    /*Divider 5*/
#define PLL1_PLLDIV6    *(unsigned int*) (PLL1_BASE + 0x168)    /*Divider 6*/
#define PLL1_PLLDIV7    *(unsigned int*) (PLL1_BASE + 0x16C)    /*Divider 7*/
#define PLL1_PLLDIV8    *(unsigned int*) (PLL1_BASE + 0x170)    /*Divider 8*/
#define PLL1_PLLDIV9    *(unsigned int*) (PLL1_BASE + 0x174)    /*Divider 9*/
#define PLL1_PLLDIV10   *(unsigned int*) (PLL1_BASE + 0x178)    /*Divider 10*/
#define PLL1_PLLDIV11   *(unsigned int*) (PLL1_BASE + 0x17C)    /*Divider 11*/
#define PLL1_PLLDIV12   *(unsigned int*) (PLL1_BASE + 0x180)    /*Divider 12*/
#define PLL1_PLLDIV13   *(unsigned int*) (PLL1_BASE + 0x184)    /*Divider 13*/
#define PLL1_PLLDIV14   *(unsigned int*) (PLL1_BASE + 0x188)    /*Divider 14*/
#define PLL1_PLLDIV15   *(unsigned int*) (PLL1_BASE + 0x18C)    /*Divider 15*/
#define PLL1_PLLDIV16   *(unsigned int*) (PLL1_BASE + 0x190)    /*Divider 16*/

/*PSC Module Related Registers*/
#define PSC0_BASE       0x01C10000
#define PSC1_BASE       0x01E27000

#define PSC0_MDCTL      (PSC0_BASE+0xA00)
#define PSC0_MDSTAT     (PSC0_BASE+0x800)
#define PSC0_PTCMD      *(unsigned int*) (PSC0_BASE + 0x120)
#define PSC0_PTSTAT     *(unsigned int*) (PSC0_BASE + 0x128)

#define PSC1_MDCTL      (PSC1_BASE+0xA00)
#define PSC1_MDSTAT     (PSC1_BASE+0x800)
#define PSC1_PTCMD      *(unsigned int*) (PSC1_BASE + 0x120)
#define PSC1_PTSTAT     *(unsigned int*) (PSC1_BASE + 0x128)

#define PSC_TIMEOUT      200 // This value can be optimized by the user

#define LPSC_EDMA_CC0    0
#define LPSC_EDMA_TC0    1
#define LPSC_EDMA_TC1    2
#define LPSC_EMIFA       3   /*PSC0*/
#define LPSC_SPI0        4   /*PSC0*/
#define LPSC_MMCSD0      5   /*PSC0*/
#define LPSC_ARM_AINTC   6
#define LPSC_ARM_RAMROM  7   /*PSC0*/
// LPSC #8 not used
#define LPSC_UART0       9   /*PSC0*/
#define LPSC_SCR0        10
#define LPSC_SCR1        11
#define LPSC_SCR2        12
#define LPSC_PRU         13  /*PSC0*/
#define LPSC_ARM         14  /*PSC0*/
#define LPSC_DSP         15  /*PSC0*/

#define LPSC_EDMA_CC1    0
#define LPSC_USB20       1   /*PSC1*/
#define LPSC_USB11       2   /*PSC1*/
#define LPSC_GPIO        3   /*PSC1*/
#define LPSC_UHPI        4   /*PSC1*/
#define LPSC_EMAC        5   /*PSC1*/
#define LPSC_DDR         6   /*PSC1*/
#define LPSC_MCASP0      7   /*PSC1*/
#define LPSC_SATA        8   /*PSC1*/
#define LPSC_VPIF        9   /*PSC1*/
#define LPSC_SPI1        10  /*PSC1*/
#define LPSC_I2C1        11  /*PSC1*/
#define LPSC_UART1       12  /*PSC1*/
#define LPSC_UART2       13  /*PSC1*/
#define LPSC_MCBSP0      14  /*PSC1*/
#define LPSC_MCBSP1      15  /*PSC1*/
#define LPSC_LCDC        16  /*PSC1*/
#define LPSC_EPWM        17  /*PSC1*/
#define LPSC_MMCSD1      18
#define LPSC_UPP         19
#define LPSC_ECAP        20
#define LPSC_EDMA_TC2    21
// LPSC #22-23 not used
#define LPSC_SCR_F0      24
#define LPSC_SCR_F1      25
#define LPSC_SCR_F2      26
#define LPSC_SCR_F6      27
#define LPSC_SCR_F7      28
#define LPSC_SCR_F8      29
#define LPSC_BR_F7       30
#define LPSC_SHARED_RAM  31

/*DDR MMR Declaration*/
#define VTPIO_CTL           *(unsigned int*)(0x01E2C000)                  // VTPIO_CTL Register
#define EMIFDDR_SDRAM_CFG   0xB0000000
#define EMIFDDR_REVID       *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x00)      //EMIF Module ID and Revision Register
#define EMIFDDR_SDRSTAT     *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x04)      //SDRAM Status Register
#define EMIFDDR_SDCR        *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x08)      //SDRAM Bank Config Register
#define EMIFDDR_SDRCR       *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x0C)      //SDRAM Refresh Control Register
#define EMIFDDR_SDTIMR1     *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x10)      //SDRAM Timing Register1
#define EMIFDDR_SDTIMR2     *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x14)      //SDRAM Timing Register2
#define EMIFDDR_SDCR2       *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x1C)      //SDRAM Config Register2
#define EMIFDDR_PBBPR       *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x20)      //VBUSM Burst Priority Register
#define EMIFDDR_VBUSMCFG1   *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x28)      //VBUSM config Value1 Register
#define EMIFDDR_VBUSMCFG2   *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0x2C)      //VBUSM config Value2 Register
#define EMIFDDR_IRR         *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xC0)      //Interrupt Raw Register
#define EMIFDDR_IMR         *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xC4)      //Interrupt Masked Register
#define EMIFDDR_IMSR        *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xC8)      //Interrupt Mask Set Register
#define EMIFDDR_IMCR        *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xCC)      //Interrupt Mask Clear Register
#define DDRPHYREV           *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xE0)      //DDR PHY ID and Revision Register
#define DRPYC1R             *(unsigned int*)(EMIFDDR_SDRAM_CFG + 0xE4)      //DDR PHY Control 1 Register

#define DDR2 0              // Do not change this value
#define MDDR 1              // Do not change this value
#define VTP_TIMEOUT 200     // This value can be optimized by the user
#define DDR_DEBUG 0         // Set this to "1" to program DDR with more timing slack

#define EMIFDDR_BASE_ADDR       0xC0000000
#define EMIFA_BASE_ADDR         0x40000000
#define EMIFA_CS2_BASE_ADDR     0x60000000
#define EMIFA_CS3_BASE_ADDR     0x62000000
#define EMIFA_CS4_BASE_ADDR     0x64000000
#define EMIFA_CS5_BASE_ADDR     0x66000000

/*EMIF2.5 MMR Declaration*/
#define EMIFA             0x68000000

#define EMIFA_AWAITCFG    *(unsigned int*)(EMIFA + 0x04)
#define EMIFA_SDCFG       *(unsigned int*)(EMIFA + 0x08)
#define EMIFA_SDREF       *(unsigned int*)(EMIFA + 0x0C)
#define EMIFA_ACFG2       *(unsigned int*)(EMIFA + 0x10)    //Async Bank1 Config Register
#define EMIFA_ACFG3       *(unsigned int*)(EMIFA + 0x14)    //Async Bank2 Config Register
#define EMIFA_ACFG4       *(unsigned int*)(EMIFA + 0x18)    //Async Bank3 Config Register
#define EMIFA_ACFG5       *(unsigned int*)(EMIFA + 0x1C)    //Async Bank4 Config Register
#define EMIFA_SDTIM       *(unsigned int*)(EMIFA + 0x20)    //SDRAM Timing Register
#define EMIFA_SRPD        *(unsigned int*)(EMIFA + 0x3C)
#define EMIFA_NANDFCR     *(unsigned int*)(EMIFA + 0x60)

/*GPIO MMR*/
#define GPIO_REG_BASE         (0x01E26000)
#define GPIO_BANK_OFFSET      (0x28)
#define GPIO_DAT_OFFSET       (0x04)
#define GPIO_SET_OFFSET       (0x08)
#define GPIO_CLR_OFFSET       (0x0C)
#define GPIO_BINTEN           *(unsigned int*)(GPIO_REG_BASE + 0x08)
#define GPIO_BANK01_BASE      (GPIO_REG_BASE + 0x10)
#define GPIO_BANK23_BASE      (GPIO_BANK01_BASE + GPIO_BANK_OFFSET)
#define GPIO_BANK45_BASE      (GPIO_BANK23_BASE + GPIO_BANK_OFFSET)
#define GPIO_BANK67_BASE      (GPIO_BANK45_BASE + GPIO_BANK_OFFSET)
#define GPIO_BANK8_BASE       (GPIO_BANK67_BASE + GPIO_BANK_OFFSET)
#define GPIO_BANK23_DIR       *(unsigned int*)(GPIO_BANK23_BASE)
#define GPIO_BANK23_DAT       *(unsigned int*)(GPIO_BANK23_BASE + GPIO_DAT_OFFSET)
#define GPIO_BANK23_SET       *(unsigned int*)(GPIO_BANK23_BASE + GPIO_SET_OFFSET)
#define GPIO_BANK23_CLR       *(unsigned int*)(GPIO_BANK23_BASE + GPIO_CLR_OFFSET)

/*System MMR Declaration*/
#define SYS_BASE           0x01C14000
#define HOST0CFG           *(unsigned int*)(SYS_BASE + 0x040)  //ARM HOST0CFG
#define KICK0R             *(unsigned int*)(SYS_BASE + 0x038)
#define KICK1R             *(unsigned int*)(SYS_BASE + 0x03c)
#define PINMUX0            *(unsigned int*)(SYS_BASE + 0x120)  //PINMUX0
#define PINMUX1            *(unsigned int*)(SYS_BASE + 0x124)  //PINMUX1
#define PINMUX2            *(unsigned int*)(SYS_BASE + 0x128)  //PINMUX2
#define PINMUX3            *(unsigned int*)(SYS_BASE + 0x12C)  //PINMUX3
#define PINMUX4            *(unsigned int*)(SYS_BASE + 0x130)  //PINMUX4
#define PINMUX5            *(unsigned int*)(SYS_BASE + 0x134)  //PINMUX5
#define PINMUX6            *(unsigned int*)(SYS_BASE + 0x138)  //PINMUX6
#define PINMUX7            *(unsigned int*)(SYS_BASE + 0x13C)  //PINMUX7
#define PINMUX8            *(unsigned int*)(SYS_BASE + 0x140)  //PINMUX8
#define PINMUX9            *(unsigned int*)(SYS_BASE + 0x144)  //PINMUX9
#define PINMUX10           *(unsigned int*)(SYS_BASE + 0x148)  //PINMUX10
#define PINMUX11           *(unsigned int*)(SYS_BASE + 0x14C)  //PINMUX11
#define PINMUX12           *(unsigned int*)(SYS_BASE + 0x150)  //PINMUX12
#define PINMUX13           *(unsigned int*)(SYS_BASE + 0x154)  //PINMUX13
#define PINMUX14           *(unsigned int*)(SYS_BASE + 0x158)  //PINMUX14
#define PINMUX15           *(unsigned int*)(SYS_BASE + 0x15C)  //PINMUX15
#define PINMUX16           *(unsigned int*)(SYS_BASE + 0x160)  //PINMUX16
#define PINMUX17           *(unsigned int*)(SYS_BASE + 0x164)  //PINMUX17
#define PINMUX18           *(unsigned int*)(SYS_BASE + 0x168)  //PINMUX18
#define PINMUX19           *(unsigned int*)(SYS_BASE + 0x16C)  //PINMUX19
#define CFGCHIP0           *(unsigned int*)(SYS_BASE + 0x17C)
#define CFGCHIP2           *(unsigned int*)(SYS_BASE + 0x184)
#define CFGCHIP3           *(unsigned int*)(SYS_BASE + 0x188)
#define PD0                0   /*Power Domain-0*/
#define PD1                1   /*Power Domain-1*/

#define PLLEN_MUX_SWITCH         4
#define PLL_LOCK_TIME_CNT        2400
#define PLL_STABILIZATION_TIME   2000
#define PLL_RESET_TIME_CNT       200

OnTargetConnect( )
{
    GEL_TextOut("\tTarget Connected.\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
	
    CPU_PLL_PSC_DDR_Init();
}

menuitem "Initiation"
hotmenu CPU_PLL_PSC_DDR_Init()
{
    Clear_Memory_Map();
    Setup_Memory_Map();
    
    PSC_All_On();
    Core_456MHz_DDR2_156MHz();

    Wake_DSP();
	Wake_PRU();
}

Wake_DSP()
{
    PSC0_LPSC_enableCore(1, LPSC_DSP);

    GEL_TextOut("\tDSP Wake Complete.(Only For OMAPL138)\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

Wake_PRU()
{
    PSC0_LPSC_enableCore(0, LPSC_PRU);

    GEL_TextOut("\tPRU Wake Complete.\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

Clear_Memory_Map()
{
    GEL_MapOff( );
    GEL_MapReset( );
    GEL_TextOut("\tMemory Map Cleared.\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

Setup_Memory_Map()
{
    GEL_MapOn( );
    GEL_MapReset( );

    /* PRU */
    GEL_MapAddStr( 0x00000000, 0, 0x00000FFF, "R|W|AS4", 0 );   // PRUSS Local Address Space
    GEL_MapAddStr( 0x01C30000, 0, 0x01C301FF, "R|W|AS4", 0 );   // Data RAM 0
    GEL_MapAddStr( 0x01C32000, 0, 0x01C321FF, "R|W|AS4", 0 );   // Data RAM 1
    GEL_MapAddStr( 0x01C34000, 0, 0x01C36FFF, "R|W|AS4", 0 );   // INTC Registers
    GEL_MapAddStr( 0x01C37000, 0, 0x01C377FF, "R|W|AS4", 0 );   // PRU0 Registers 
    GEL_MapAddStr( 0x01C37800, 0, 0x01C37FFF, "R|W|AS4", 0 );   // PRU1 Registers 
    GEL_MapAddStr( 0x01C38000, 0, 0x01C38FFF, "R|W|AS4", 0 );   // PRU0 Instruction RAM
    GEL_MapAddStr( 0x01C3C000, 0, 0x01C3CFFF, "R|W|AS4", 0 );   // PRU1 Instruction RAM
	
    /* ARM */
    GEL_MapAddStr( 0xFFFD0000, 0, 0x00010000, "R|W|AS4", 0 );   // ARM Local ROM
    GEL_MapAddStr( 0xFFFEE000, 0, 0x00001000, "R|W|AS4", 0 );   // ARM INTC
    GEL_MapAddStr( 0xFFFF0000, 0, 0x00002000, "R|W|AS4", 0 );   // ARM Local RAM
    GEL_MapAddStr( 0x01BC0000, 0, 0x00001000, "R|W|AS4", 0 );   // ARM ETB Memory
    GEL_MapAddStr( 0x01BC1000, 0, 0x00000800, "R|W|AS4", 0 );   // ARM ETB Regs
    GEL_MapAddStr( 0x01BC1800, 0, 0x00000100, "R|W|AS4", 0 );   // ARM Ice Crusher

    /* DSP */
    GEL_MapAddStr( 0x00700000, 0, 0x00100000, "R|W|AS4", 0 );   // DSP L2 ROM
    GEL_MapAddStr( 0x00800000, 0, 0x00040000, "R|W|AS4", 0 );   // DSP l2 RAM
    GEL_MapAddStr( 0x00E00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1P RAM
    GEL_MapAddStr( 0x00F00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1D RAM
    GEL_MapAddStr( 0x01800000, 0, 0x00010000, "R|W|AS4", 0 );   // DSP Interrupt Controller
    GEL_MapAddStr( 0x01810000, 0, 0x00001000, "R|W|AS4", 0 );   // DSP Powerdown Controller
    GEL_MapAddStr( 0x01811000, 0, 0x00001000, "R|W|AS4", 0 );   // DSP Security ID
    GEL_MapAddStr( 0x01812000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP Revision ID
    GEL_MapAddStr( 0x01820000, 0, 0x00010000, "R|W|AS4", 0 );   // DSP EMC
    GEL_MapAddStr( 0x01830000, 0, 0x00010000, "R|W|AS4", 0 );   // DSP Internal Reserved
    GEL_MapAddStr( 0x01840000, 0, 0x00010000, "R|W|AS4", 0 );   // DSP Memory System

    GEL_MapAddStr( 0x11700000, 0, 0x00100000, "R|W|AS4", 0 );   // DSP L2 ROM (mirror)
    GEL_MapAddStr( 0x11800000, 0, 0x00040000, "R|W|AS4", 0 );   // DSP l2 RAM (mirror)
    GEL_MapAddStr( 0x11E00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1P RAM (mirror)
    GEL_MapAddStr( 0x11F00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1D RAM (mirror)
 
    /* Shared RAM */
    GEL_MapAddStr( 0x80000000, 0, 0x00020000, "R|W|AS4", 0 );   // Shared RAM

    /* EMIFA */
    GEL_MapAddStr( 0x40000000, 0, 0x20000000, "R|W|AS4", 0 );   // EMIFA SDRAM Data
    GEL_MapAddStr( 0x60000000, 0, 0x02000000, "R|W|AS4", 0 );   // EMIFA CS2
    GEL_MapAddStr( 0x62000000, 0, 0x02000000, "R|W|AS4", 0 );   // EMIFA CS3
    GEL_MapAddStr( 0x64000000, 0, 0x02000000, "R|W|AS4", 0 );   // EMIFA CS4
    GEL_MapAddStr( 0x66000000, 0, 0x02000000, "R|W|AS4", 0 );   // EMIFA CS5
    GEL_MapAddStr( 0x68000000, 0, 0x00008000, "R|W|AS4", 0 );   // EMIFA Control

    /* DDR */
    GEL_MapAddStr( 0xB0000000, 0, 0x00008000, "R|W|AS4", 0 );   // DDR Control
    GEL_MapAddStr( 0xC0000000, 0, 0x20000000, "R|W|AS4", 0 );   // DDR Data

    /* Peripherals */
    GEL_MapAddStr( 0x01C00000, 0, 0x00008000, "R|W|AS4", 0 );   // TPCC0
    GEL_MapAddStr( 0x01C08000, 0, 0x00000400, "R|W|AS4", 0 );   // TPTC0
    GEL_MapAddStr( 0x01C08400, 0, 0x00000400, "R|W|AS4", 0 );   // TPTC1
    GEL_MapAddStr( 0x01C10000, 0, 0x00001000, "R|W|AS4", 0 );   // PSC 0
    GEL_MapAddStr( 0x01C11000, 0, 0x00001000, "R|W|AS4", 0 );   // PLL Controller 0
    GEL_MapAddStr( 0x01C12000, 0, 0x00001000, "R|W|AS4", 0 );   // Key Manager
    GEL_MapAddStr( 0x01C13000, 0, 0x00001000, "R|W|AS4", 0 );   // SecCo
    GEL_MapAddStr( 0x01C14000, 0, 0x00001000, "R|W|AS4", 0 );   // SysConfig
    GEL_MapAddStr( 0x01C16000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 0
    GEL_MapAddStr( 0x01C17000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 2
    GEL_MapAddStr( 0x01C20000, 0, 0x00001000, "R|W|AS4", 0 );   // Timer64P 0
    GEL_MapAddStr( 0x01C21000, 0, 0x00001000, "R|W|AS4", 0 );   // Timer64P 1
    GEL_MapAddStr( 0x01C22000, 0, 0x00001000, "R|W|AS4", 0 );   // I2C 0
    GEL_MapAddStr( 0x01C23000, 0, 0x00001000, "R|W|AS4", 0 );   // RTC
    GEL_MapAddStr( 0x01C24000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 1
    GEL_MapAddStr( 0x01C30000, 0, 0x00000200, "R|W|AS4", 0 );   // PRU Data RAM 0
    GEL_MapAddStr( 0x01C32000, 0, 0x00000200, "R|W|AS4", 0 );   // PRU Data RAM 1
    GEL_MapAddStr( 0x01C34000, 0, 0x00004000, "R|W|AS4", 0 );   // PRU Control Registers
    GEL_MapAddStr( 0x01C38000, 0, 0x00001000, "R|W|AS4", 0 );   // PRU 0 Config Memory
    GEL_MapAddStr( 0x01C3C000, 0, 0x00001000, "R|W|AS4", 0 );   // PRU 1 Config Memory
    GEL_MapAddStr( 0x01C40000, 0, 0x00001000, "R|W|AS4", 0 );   // MMC/SD 0
    GEL_MapAddStr( 0x01C41000, 0, 0x00001000, "R|W|AS4", 0 );   // SPI 0
    GEL_MapAddStr( 0x01C42000, 0, 0x00001000, "R|W|AS4", 0 );   // UART 0
    GEL_MapAddStr( 0x01C43000, 0, 0x00001000, "R|W|AS4", 0 );   // MPU 0
    GEL_MapAddStr( 0x01D00000, 0, 0x00001000, "R|W|AS4", 0 );   // McASP 0 Control
    GEL_MapAddStr( 0x01D01000, 0, 0x00001000, "R|W|AS4", 0 );   // McASP 0 FIFO Ctrl
    GEL_MapAddStr( 0x01D02000, 0, 0x00001000, "R|W|AS4", 0 );   // McASP 0 Data
    GEL_MapAddStr( 0x01D0C000, 0, 0x00001000, "R|W|AS4", 0 );   // UART 1
    GEL_MapAddStr( 0x01D0D000, 0, 0x00001000, "R|W|AS4", 0 );   // UART 2
    GEL_MapAddStr( 0x01D0E000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 4
    GEL_MapAddStr( 0x01D10000, 0, 0x00000800, "R|W|AS4", 0 );   // McBSP 0 Control
    GEL_MapAddStr( 0x01D10800, 0, 0x00000200, "R|W|AS4", 0 );   // McBSP 0 FIFO Ctrl
    GEL_MapAddStr( 0x01D11000, 0, 0x00000800, "R|W|AS4", 0 );   // McBSP 1 Control
    GEL_MapAddStr( 0x01D11800, 0, 0x00000200, "R|W|AS4", 0 );   // McBSP 1 FIFO Ctrl
    GEL_MapAddStr( 0x01E00000, 0, 0x00010000, "R|W|AS4", 0 );   // USB0 (USB HS) Cfg
    GEL_MapAddStr( 0x01E10000, 0, 0x00001000, "R|W|AS4", 0 );   // UHPI Cfg
    GEL_MapAddStr( 0x01E11000, 0, 0x00001000, "R|W|AS4", 0 );   // UHPI (IODFT)
    GEL_MapAddStr( 0x01E13000, 0, 0x00001000, "R|W|AS4", 0 );   // LCD Controller
    GEL_MapAddStr( 0x01E14000, 0, 0x00001000, "R|W|AS4", 0 );   // MPU 1
    GEL_MapAddStr( 0x01E15000, 0, 0x00001000, "R|W|AS4", 0 );   // MPU 2
    GEL_MapAddStr( 0x01E16000, 0, 0x00001000, "R|W|AS4", 0 );   // UPP
    GEL_MapAddStr( 0x01E17000, 0, 0x00001000, "R|W|AS4", 0 );   // VPIF
    GEL_MapAddStr( 0x01E18000, 0, 0x00002000, "R|W|AS4", 0 );   // SATA
    GEL_MapAddStr( 0x01E1A000, 0, 0x00001000, "R|W|AS4", 0 );   // PLL Controller 1
    GEL_MapAddStr( 0x01E1B000, 0, 0x00001000, "R|W|AS4", 0 );   // MMC/SD 1
    GEL_MapAddStr( 0x01E20000, 0, 0x00002000, "R|W|AS4", 0 );   // EMAC CPPI
    GEL_MapAddStr( 0x01E22000, 0, 0x00001000, "R|W|AS4", 0 );   // EMAC CONTROL registers
    GEL_MapAddStr( 0x01E23000, 0, 0x00001000, "R|W|AS4", 0 );   // EMAC registers
    GEL_MapAddStr( 0x01E24000, 0, 0x00001000, "R|W|AS4", 0 );   // EMAC MDIO port
    GEL_MapAddStr( 0x01E25000, 0, 0x00001000, "R|W|AS4", 0 );   // USB1 (USB FS)
    GEL_MapAddStr( 0x01E26000, 0, 0x00001000, "R|W|AS4", 0 );   // GPIO
    GEL_MapAddStr( 0x01E27000, 0, 0x00001000, "R|W|AS4", 0 );   // PSC 1
    GEL_MapAddStr( 0x01E28000, 0, 0x00001000, "R|W|AS4", 0 );   // I2C 1
    GEL_MapAddStr( 0x01E29000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 3
    GEL_MapAddStr( 0x01E2A000, 0, 0x00001000, "R|W|AS4", 0 );   // PBIST Controller
    GEL_MapAddStr( 0x01E2B000, 0, 0x00001000, "R|W|AS4", 0 );   // PBIST Combiner
    GEL_MapAddStr( 0x01E2C000, 0, 0x00001000, "R|W|AS4", 0 );   // System Config

    GEL_MapAddStr( 0x01E30000, 0, 0x00008000, "R|W|AS4", 0 );   // TPCC1
    GEL_MapAddStr( 0x01E38000, 0, 0x00000400, "R|W|AS4", 0 );   // TPTC2
    GEL_MapAddStr( 0x01F00000, 0, 0x00001000, "R|W|AS4", 0 );   // EPWM 0
    GEL_MapAddStr( 0x01F01000, 0, 0x00001000, "R|W|AS4", 0 );   // HRPWM 0
    GEL_MapAddStr( 0x01F02000, 0, 0x00001000, "R|W|AS4", 0 );   // EPWM 1
    GEL_MapAddStr( 0x01F03000, 0, 0x00001000, "R|W|AS4", 0 );   // HRPWM 1
    GEL_MapAddStr( 0x01F06000, 0, 0x00001000, "R|W|AS4", 0 );   // ECAP 0
    GEL_MapAddStr( 0x01F07000, 0, 0x00001000, "R|W|AS4", 0 );   // ECAP 1
    GEL_MapAddStr( 0x01F08000, 0, 0x00001000, "R|W|AS4", 0 );   // ECAP 2
    GEL_MapAddStr( 0x01F0B000, 0, 0x00001000, "R|W|AS4", 0 );   // IOPU 5
    GEL_MapAddStr( 0x01F0C000, 0, 0x00001000, "R|W|AS4", 0 );   // Timer64P 2
    GEL_MapAddStr( 0x01F0D000, 0, 0x00001000, "R|W|AS4", 0 );   // Timer64P 3
    GEL_MapAddStr( 0x01F0E000, 0, 0x00001000, "R|W|AS4", 0 );   // SPI1
    GEL_MapAddStr( 0x01F10000, 0, 0x00001000, "R|W|AS4", 0 );   // McBSP 0 FIFO Data
    GEL_MapAddStr( 0x01F11000, 0, 0x00001000, "R|W|AS4", 0 );   // McBSP 1 FIFO Data
    GEL_TextOut("\tMemory Map Setup Complete.\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

Set_Core_456MHz() {
    device_PLL0(0,18,0,0,1,3,9);
    GEL_TextOut("\tPLL0 init done for Core:456MHz, EMIFA:114MHz\n","Output",1,1,1);
}

Set_DDRPLL_156MHz() {
    device_PLL1(12,0,0,1,2);
    GEL_TextOut("\tPLL1 init done for DDR:156MHz\n","Output",1,1,1);
}

Set_DDR2_156MHz() {
    GEL_TextOut("\tDDR initialization is in progress....\n","Output",1,1,1);
    Set_DDRPLL_156MHz();
    DEVICE_DDRConfig();
    GEL_TextOut("\tDDR2 init for 156 MHz is done\n","Output",1,1,1);
}

Core_456MHz_DDR2_156MHz() {
    Set_Core_456MHz();
    Set_DDR2_156MHz();
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

PSC_All_On() {
    // PSC0
    PSC0_LPSC_enable(0, LPSC_EDMA_CC0);
    PSC0_LPSC_enable(0, LPSC_EDMA_TC0);
    PSC0_LPSC_enable(0, LPSC_EDMA_TC1);
    PSC0_LPSC_enable(0, LPSC_EMIFA);
    PSC0_LPSC_enable(0, LPSC_SPI0);
    PSC0_LPSC_enable(0, LPSC_MMCSD0);
    PSC0_LPSC_enable(0, LPSC_ARM_AINTC);
    PSC0_LPSC_enable(0, LPSC_ARM_RAMROM);
    PSC0_LPSC_enable(0, LPSC_UART0);
    PSC0_LPSC_enable(0, LPSC_SCR0);
    PSC0_LPSC_enable(0, LPSC_SCR1);
    PSC0_LPSC_enable(0, LPSC_SCR2);

    // PSC1
    PSC1_LPSC_enable(0, LPSC_EDMA_CC1);
    PSC1_LPSC_enable(0, LPSC_USB20);
    PSC1_LPSC_enable(0, LPSC_USB11);
    CFGCHIP2 = 0x09F2;                 //Enable USB clock, PHY_PLLON, glue logic mux(USB2 ref clk input)
    PSC1_LPSC_enable(0, LPSC_GPIO);
    PSC1_LPSC_enable(0, LPSC_UHPI);
    PSC1_LPSC_enable(0, LPSC_EMAC);
    PSC1_LPSC_enable(0, LPSC_MCASP0);
    PSC1_LPSC_force(LPSC_SATA);
    PSC1_LPSC_enable(0, LPSC_SATA);
    PSC1_LPSC_enable(0, LPSC_VPIF);
    PSC1_LPSC_enable(0, LPSC_SPI1);
    PSC1_LPSC_enable(0, LPSC_I2C1);
    PSC1_LPSC_enable(0, LPSC_UART1);
    PSC1_LPSC_enable(0, LPSC_UART2);
    PSC1_LPSC_enable(0, LPSC_MCBSP0);
    PSC1_LPSC_enable(0, LPSC_MCBSP1);
    PSC1_LPSC_enable(0, LPSC_LCDC);
    PSC1_LPSC_enable(0, LPSC_EPWM);
    PSC1_LPSC_enable(0, LPSC_MMCSD1);
    PSC1_LPSC_enable(0, LPSC_UPP);
    PSC1_LPSC_enable(0, LPSC_ECAP);
    PSC1_LPSC_enable(0, LPSC_EDMA_TC2);
    PSC1_LPSC_enable(0, LPSC_SCR_F0);
    PSC1_LPSC_enable(0, LPSC_SCR_F1);
    PSC1_LPSC_enable(0, LPSC_SCR_F2);
    PSC1_LPSC_enable(0, LPSC_SCR_F6);
    PSC1_LPSC_enable(0, LPSC_SCR_F7);
    PSC1_LPSC_enable(0, LPSC_SCR_F8);
    PSC1_LPSC_enable(0, LPSC_BR_F7);
    PSC1_LPSC_enable(0, LPSC_SHARED_RAM);

    GEL_TextOut("\tPSC Enable Complete.\n","Output",1,1,1);
    GEL_TextOut("\t---------------------------------------------\n","Output",1,1,1);
}

/**************************************************************************************************************************************************
   Device_PLL0 init:

   CLKMODE -  0---->On Chip Oscilator  1---->External Oscilator
   PLL0_SYSCLK1 - Fixed ratio /1
   PLL0_SYSCLK2 - Fixed ratio /2
   PLL0_SYSCLK3 - Variable Divider (EMIFA)
   PLL0_SYSCLK4 - Fixed ratio /4
   PLL0_SYSCLK5 - Not used -- do nothing
   PLL0_SYSCLK6 - Fixed ratio /1
   PLL0_SYSCLK7 - Variable Divider (RMII)
******************************************************************************************************************************************************/
device_PLL0(unsigned int CLKMODE, unsigned int PLLM, unsigned int POSTDIV,unsigned int PLLDIV1, unsigned int PLLDIV2, unsigned int PLLDIV3, unsigned int PLLDIV7 ) {

    unsigned int i=0;

    /* Clear PLL lock bit */
    CFGCHIP0 &= ~(0x00000010);

    /* Set PLLENSRC '0',bit 5, PLL Enable(PLLEN) selection is controlled through MMR */
    PLL0_PLLCTL &= ~(0x00000020);

    /* PLLCTL.EXTCLKSRC bit 9 should be left at 0 for Freon */
    PLL0_PLLCTL &= ~(0x00000200);

    /* Set PLLEN=0 to put in bypass mode*/
    PLL0_PLLCTL &= ~(0x00000001);

    /*wait for 4 cycles to allow PLLEN mux switches properly to bypass clock*/
    for(i=0; i<PLLEN_MUX_SWITCH; i++) {;}

    /* Select the Clock Mode bit 8 as External Clock or On Chip Oscilator*/
    PLL0_PLLCTL &= 0xFFFFFEFF;
    PLL0_PLLCTL |= (CLKMODE << 8);

    /*Clear PLLRST bit to reset the PLL */
    PLL0_PLLCTL &= ~(0x00000008);

    /* Disable the PLL output*/
    PLL0_PLLCTL |= (0x00000010);

    /* PLL initialization sequence
    Power up the PLL by setting PWRDN bit set to 0 */
    PLL0_PLLCTL &= ~(0x00000002);

    /* Enable the PLL output*/
    PLL0_PLLCTL &= ~(0x00000010);

    /*PLL stabilisation time- take out this step , not required here when PLL in bypassmode*/
    for(i=0; i<PLL_STABILIZATION_TIME; i++) {;}

    /*Program the required multiplier value in PLLM*/
    PLL0_PLLM    = PLLM;

    /*If desired to scale all the SYSCLK frequencies of a given PLLC, program the POSTDIV ratio*/
    PLL0_POSTDIV = 0x8000 | POSTDIV;

    /*Check for the GOSTAT bit in PLLSTAT to clear to 0 to indicate that no GO operation is currently in progress*/
    while(PLL0_PLLSTAT & 0x1==1){}

    /*Program the RATIO field in PLLDIVx with the desired divide factors. In addition, make sure in this step you leave the PLLDIVx.DxEN bits set so clocks are still enabled (default).*/
    PLL0_PLLDIV1 = 0x8000 | PLLDIV1;             // Fixed Ratio /1
    PLL0_PLLDIV2 = 0x8000 | PLLDIV2;             // Fixed Ratio /2
    PLL0_PLLDIV4 = 0x8000 | (((PLLDIV1+1)*4)-1); // Fixed Ratio /4
    PLL0_PLLDIV6 = 0x8000 | PLLDIV1;             // Fixed Ratio /1
    PLL0_PLLDIV3 = 0x8000 | PLLDIV3;             // Variable Ratio (EMIF)
    PLL0_PLLDIV7 = 0x8000 | PLLDIV7;             // Variable Ratio (RMII)


    /*Set the GOSET bit in PLLCMD to 1 to initiate a new divider transition.*/
    PLL0_PLLCMD |= 0x1;

    /*Wait for the GOSTAT bit in PLLSTAT to clear to 0 (completion of phase alignment).*/
    while(PLL0_PLLSTAT & 0x1==1) { }

    /*Wait for PLL to reset properly.*/
    for(i=0; i<PLL_RESET_TIME_CNT; i++) {;}

    /*Set the PLLRST bit in PLLCTL to 1 to bring the PLL out of reset*/
    PLL0_PLLCTL |= 0x8;

    /*Wait for PLL to lock.*/
    for(i=0; i<PLL_LOCK_TIME_CNT; i++) {;}

    /*Set the PLLEN bit in PLLCTL to 1 to remove the PLL from bypass mode*/
    PLL0_PLLCTL |=  0x1;
}

/**********************************************************************************
DDR PLL1 init:

***********************************************************************************/
device_PLL1(unsigned int PLLM,unsigned int POSTDIV,unsigned int PLLDIV1, unsigned int PLLDIV2, unsigned int PLLDIV3 ) {

    unsigned int i=0;

    /* Clear PLL lock bit */
    CFGCHIP3 &= ~(0x00000020);

    /* Set PLLENSRC '0',bit 5, PLL Enable(PLLEN) selection is controlled through MMR */
    PLL1_PLLCTL &= ~(0x00000020);

    /* PLLCTL.EXTCLKSRC bit 9 should be left at 0 for Freon */
    PLL1_PLLCTL &= ~(0x00000200);

    /* Set PLLEN=0 to put in bypass mode*/
    PLL1_PLLCTL &= ~(0x00000001);

    /*wait for 4 cycles to allow PLLEN mux switches properly to bypass clock*/
    for(i=0; i<PLLEN_MUX_SWITCH; i++) {;}

    /*Clear PLLRST bit to reset the PLL */
    PLL1_PLLCTL &= ~(0x00000008);

    /* Disable the PLL output*/
    PLL1_PLLCTL |= (0x00000010);

    /* PLL initialization sequence
    Power up the PLL by setting PWRDN bit set to 0 */
    PLL1_PLLCTL &= ~(0x00000002);

    /* Enable the PLL output*/
    PLL1_PLLCTL &= ~(0x00000010);

    /*PLL stabilisation time- take out this step , not required here when PLL in bypassmode*/
    for(i=0; i<PLL_STABILIZATION_TIME; i++) {;}

    /*Program the required multiplier value in PLLM*/
    PLL1_PLLM    = PLLM;

    /*If desired to scale all the SYSCLK frequencies of a given PLLC, program the POSTDIV ratio*/
    PLL1_POSTDIV = 0x8000 | POSTDIV;

    /*Check for the GOSTAT bit in PLLSTAT to clear to 0 to indicate that no GO operation is currently in progress*/
    while(PLL1_PLLSTAT & 0x1==1){}

    /*Program the RATIO field in PLLDIVx with the desired divide factors. In addition, make sure in this step you leave the PLLDIVx.DxEN bits set so clocks are still enabled (default).*/
    PLL1_PLLDIV1 = 0x8000 | PLLDIV1;   // DDR frequency (aka 2X_CLK)
    PLL1_PLLDIV2 = 0x8000 | PLLDIV2;   // Optional CFGCHIP3[ASYNC3_CLKSRC] clock source
    PLL1_PLLDIV3 = 0x8000 | PLLDIV3;   // Optional PLL0 clock source

    /*Set the GOSET bit in PLLCMD to 1 to initiate a new divider transition.*/
    PLL1_PLLCMD |= 0x1;

    /*Wait for the GOSTAT bit in PLLSTAT to clear to 0 (completion of phase alignment).*/
    while(PLL1_PLLSTAT & 0x1==1) { }

    /*Wait for PLL to reset properly */
    for(i=0; i<PLL_RESET_TIME_CNT; i++) {;}

    /*Set the PLLRST bit in PLLCTL to 1 to bring the PLL out of reset*/
    PLL1_PLLCTL |= 0x8;

    /*Wait for PLL to lock. See PLL spec for PLL lock time*/
    for(i=0; i<PLL_LOCK_TIME_CNT; i++) {;}

    /*Set the PLLEN bit in PLLCTL to 1 to remove the PLL from bypass mode*/
    PLL1_PLLCTL |=  0x1;
}

/**********************************************************************************
  PSC Common functions :

***********************************************************************************/
/*Force module state without handshaking */
PSC1_LPSC_force(unsigned int LPSC_num) {
    *(unsigned int*) (PSC1_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC1_MDCTL+4*LPSC_num) | 0x80000000);
}

/*SyncReset Function for PSC1*/
PSC1_LPSC_SyncReset(unsigned int PD, unsigned int LPSC_num) {
    unsigned int j;

    if( (*(unsigned int*)(PSC1_MDSTAT+4 * LPSC_num) & 0x1F) != 0x1 ) {
      *(unsigned int*) (PSC1_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC1_MDCTL+4*LPSC_num) & 0xFFFFFFE0) | 0x0001;
      PSC1_PTCMD = 0x1<<PD;

      j = 0;
      /*Wait for power state transition to finish*/
      while( (PSC1_PTSTAT & (0x1<<PD) ) !=0) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC1 Sync Reset Transition Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }

      j = 0;
      while( (*(unsigned int*)(PSC1_MDSTAT+4 * LPSC_num) & 0x1F) !=0x1) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC1 Sync Reset Verify Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
    }
}

/*Enable Function for PSC1*/
PSC1_LPSC_enable(unsigned int PD, unsigned int LPSC_num) {
    unsigned int j;
    
    if( (*(unsigned int*)(PSC1_MDSTAT+4 * LPSC_num) & 0x1F) != 0x3 ) {
      *(unsigned int*) (PSC1_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC1_MDCTL+4*LPSC_num) & 0xFFFFFFE0) | 0x0003;
      PSC1_PTCMD = 0x1<<PD;

      j = 0;
      /*Wait for power state transition to finish*/
      while( (PSC1_PTSTAT & (0x1<<PD) ) !=0) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC1 Enable Transition Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }

      j = 0;
      while( (*(unsigned int*)(PSC1_MDSTAT+4 * LPSC_num) & 0x1F) !=0x3) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC1 Enable Verify Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
    }
}

/*LPSC Enable Function for ARM or DSP*/
PSC0_LPSC_enableCore(unsigned int PD, unsigned int LPSC_num) {
    unsigned int j;
    
    if( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x11F) != 0x103 ) {
      *(unsigned int*) (PSC0_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC0_MDCTL+4*LPSC_num) & 0xFFFFFEE0) | 0x0103;
      PSC0_PTCMD = 0x1<<PD;

      j = 0;
      /*Wait for power state transition to finish*/
      while( (PSC0_PTSTAT & (0x1<<PD) ) !=0) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Enable Core Transition Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
      
      j = 0;
      while( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x11F) !=0x103) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Enable Core Verify Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
    }
}

/*SyncReset Function for PSC0*/
PSC0_LPSC_SyncReset(unsigned int PD, unsigned int LPSC_num) {
    unsigned int j;
    
    if( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x1F) != 0x1 ) {
      *(unsigned int*) (PSC0_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC0_MDCTL+4*LPSC_num) & 0xFFFFFFE0) | 0x0001;
      PSC0_PTCMD = 0x1<<PD;

      j = 0;
      /*Wait for power state transition to finish*/
      while( (PSC0_PTSTAT & (0x1<<PD) ) !=0) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Sync Reset Transition Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }

      j = 0;
      while( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x1F) !=0x1) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Sync Reset Verify Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
    }
}

/*Enable Function for PSC0*/
PSC0_LPSC_enable(unsigned int PD, unsigned int LPSC_num) {
    unsigned int j;

    if( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x1F) != 0x3 ) {
      *(unsigned int*) (PSC0_MDCTL+4*LPSC_num) = (*(unsigned int*) (PSC0_MDCTL+4*LPSC_num) & 0xFFFFFFE0) | 0x0003;
      PSC0_PTCMD = 0x1<<PD;

      j = 0;
      /*Wait for power state transition to finish*/
      while( (PSC0_PTSTAT & (0x1<<PD) ) !=0) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Enable Transition Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }

      j = 0;
      while( (*(unsigned int*)(PSC0_MDSTAT+4 * LPSC_num) & 0x1F) !=0x3) {
        if( j++ > PSC_TIMEOUT ) {
          GEL_TextOut("\tPSC0 Enable Verify Timeout on Domain %d, LPSC %d\n","Output",1,1,1,PD,LPSC_num);
          break;
        }
      }
    }
}


/**********************************************************************************
  DDR Configuration routine:
    1. DDR Enable
    2. VTP calibration
    3. Configure DDR
    4. Set to self-refresh, enable mclkstop and DDR Sync Reset
    5. Enable DDR and disable self-refresh

  int freq is MHz

  DDR2 = 0
  MDDR = 1

  A DDR configuration spreadsheet tool is located here:
    http://processors.wiki.ti.com/index.php/Programming_mDDR/DDR2_EMIF_on_OMAP-L1x/C674x

***********************************************************************************/
// 0xB000 0008 SDCR    0x00134621
// 0xB000 000C SDRCR   0xC00004C0
// 0xB000 0010 SDTIMR1 0x16923A49
// 0xB000 0014 SDTIMR2 0x3C0DC782
// 0xB000 001C SDCR2   0x00000000
// 0xB000 00E4 DRPYC1R 0x000000C4
DEVICE_DDRConfig()
{
    unsigned int j;
    unsigned int tmp_SDCR;
    
    // Enable the Clock to EMIFDDR SDRAM
    PSC1_LPSC_enable(PD0, LPSC_DDR);

    // Begin VTP Calibration
    VTPIO_CTL &= ~0x00000040;       // Clear POWERDN
    VTPIO_CTL &= ~0x00000080;       // Clear LOCK
    VTPIO_CTL |=  0x00002000;       // Set CLKRZ in case it was cleared before (VTP looks for CLKRZ edge transition)
    VTPIO_CTL &= ~0x00002000;       // Clear CLKRZ (Use read-modify-write to ensure 1 VTP cycle wait for previous instruction)
    VTPIO_CTL |=  0x00002000;       // Set CLKRZ (Use read-modify-write to ensure 1 VTP cycle wait for previous instruction)

    j = 0;
    // Polling READY bit to see when VTP calibration is done
    while((VTPIO_CTL & 0x00008000) == 0) {
      if( j++ > VTP_TIMEOUT ) {
        GEL_TextOut("\tVTP Ready timeout\n","Output",1,1,1);           
        break;
      }
    }

    VTPIO_CTL |= 0x00000080;       // Set LOCK bit for static calibration mode
    VTPIO_CTL |= 0x00000040;       // Set POWERDN bit to power down VTP module
    // End VTP Calibration

    VTPIO_CTL |= 0x00004000;       // Set IOPWRDN to allow powerdown of input receivers when PWRDNEN is set

    // **********************************************************************************************
    // Setting based 1Gb DDR2 Samsung K4T1G164QF-BCF8
    // Config DDR timings
    DRPYC1R     = (0x0               << 8)   |  // Reserved
                  (0x1               << 7)   |  // EXT_STRBEN
                  (0x1               << 6)   |  // PWRDNEN
                  (0x0               << 3)   |  // Reserved
                  (0x4               << 0);     // RL
    // DRPYC1R Value = 0x000000C4

    if( DDR_DEBUG ) {
      // Configure EMIF with max timings for more slack
      // Try this if memory is not stable
      DRPYC1R  |=  0x7; // RL
    }

    EMIFDDR_SDCR |= 0x00800000; // Set BOOTUNLOCK

    // Settings depending on DDR2 
      tmp_SDCR = (0x0               << 25)  |  // MSDRAMEN
                 (0x1               << 20);    // DDR2EN
      GEL_TextOut("\tUsing DDR2 settings\n","Output",1,1,1);

	EMIFDDR_SDCR = tmp_SDCR                    |  // Settings that change depending on DDR2 or MDDR
				   (EMIFDDR_SDCR & 0xF0000000) |  // Reserved
				   (0x0               << 27)   |  // DDR2TERM1
				   (0x0               << 26)   |  // IBANK_POS
				   (0x0               << 24)   |  // DDRDRIVE1
				   (0x0               << 23)   |  // BOOTUNLOCK
				   (0x0               << 22)   |  // DDR2DDQS
				   (0x0               << 21)   |  // DDR2TERM0
				   (0x0               << 19)   |  // DDRDLL_DIS
				   (0x0               << 18)   |  // DDRDRIVE0
				   (0x1               << 17)   |  // DDREN
				   (0x1               << 16)   |  // SDRAMEN
				   (0x1               << 15)   |  // TIMUNLOCK
				   (0x1               << 14)   |  // NM
				   (0x0               << 12)   |  // Reserved
				   (0x3               << 9)    |  // CL
				   (0x0               << 7)    |  // Reserved
				   (0x2               << 4)    |  // IBANK
				   (0x0               << 3)    |  // Reserved
				   (0x1               << 0);      // PAGESIZE
    
    EMIFDDR_SDCR2   = 0x00000000; // IBANK_POS set to 0 so this register does not apply

    if( DDR_DEBUG ) {
      // Configure EMIF with max timings for more slack
      // Try this if memory is not stable

      EMIFDDR_SDTIMR1 = (0x7F << 25)             |  // tRFC
                        (0x07 << 22)             |  // tRP
                        (0x07 << 19)             |  // tRCD
                        (0x07 << 16)             |  // tWR
                        (0x1F << 11)             |  // tRAS
                        (0x1F << 6)              |  // tRC
                        (0x07 << 3)              |  // tRRD
                        (EMIFDDR_SDTIMR1 & 0x4)  |  // Reserved
                        (0x03 << 0);                // tWTR
    
      EMIFDDR_SDTIMR2 = (EMIFDDR_SDTIMR2 & 0x80000000)                       |  // Reserved
                        (((unsigned int) ((70000 / 3400) - 0.5))  << 27)   |  // tRASMAX (original 7812.5)
                        (0x3                                        << 25)   |  // tXP
                        (0x0                                        << 23)   |  // tODT (Not supported)
                        (0x7F                                       << 16)   |  // tXSNR
                        (0xFF                                       << 8)    |  // tXSRD
                        (0x07                                       << 5)    |  // tRTP (1 Cycle)
                        (0x1F                                       << 0);      // tCKE

      GEL_TextOut("\tDDR Timings Configured for Debug\n","Output",1,1,1);
    }
    else {
      // Let float -> integer truncate handle minus 1; Safer to round up for timings
	  EMIFDDR_SDTIMR1 = (11                                      << 25)  |  // tRFC
						(2                                       << 22)  |  // tRP
						(2                                       << 19)  |  // tRCD
						(2                                       << 16)  |  // tWR
						(7                                       << 11)  |  // tRAS
						(9                                       <<  6)  |  // tRC
						(1                                       <<  3)  |  // tRRD
						(0                                       <<  2)  |  // Reserved
						(1                                       <<  0);    // tWTR
    
	  EMIFDDR_SDTIMR2 = (EMIFDDR_SDTIMR2 & 0x80000000)                   |  // Reserved
						(7                                       << 27)  |  // tRASMAX
						(2                                       << 25)  |  // tXP
						(0                                       << 23)  |  // tODT (Not supported)
						(13                                      << 16)  |  // tXSNR (tXSR for mDDR)
						(199                                     << 8)   |  // tXSRD (tXSR for mDDR)
						(4                                       << 5)   |  // tRTP
						(2                                       << 0);     // tCKE
    }
  
    EMIFDDR_SDCR    &= ~0x00008000; // Clear TIMUNLOCK

    // Let float -> integer truncate handle RR round-down; Safer to round down for refresh rate
    EMIFDDR_SDRCR   = (0x1                                  << 31)  |  // LPMODEN (Required for LPSC SyncReset/Enable)
                      (0x1                                  << 30)  |  // MCLKSTOPEN (Required for LPSC SyncReset/Enable)
                      (0x0                                  << 24)  |  // Reserved
                      (0x0                                  << 23)  |  // SR_PD
                      (0x0                                  << 16)  |  // Reserved
                      (0x4C0                                << 0);     // RR

    // SyncReset the Clock to EMIFDDR SDRAM
    PSC1_LPSC_SyncReset(PD0, LPSC_DDR);

    // Enable the Clock to EMIFDDR SDRAM
    PSC1_LPSC_enable(PD0, LPSC_DDR);

    // Disable self-refresh
    EMIFDDR_SDRCR &= ~0xC0000000;
        
    EMIFDDR_PBBPR = 0x10; 
}

// Input clock to device in MHz
#define OSCIN_FREQ		24

#define ARM_ROM_ID			*(unsigned int*)  0xFFFD000c
#define DSP_ROM_ID			*(unsigned int*)  0x1170000c

#define ARM_BLCfgStruct     *(unsigned int*)0xFFFF0700
#define DSP_BLCfgStruct     *(unsigned int*)0x11F00700

#define SYS_BASE            0x01C14000
#define DEV_INFO_24         *(unsigned int*)(SYS_BASE + 0x008)
#define DEV_INFO_25         *(unsigned int*)(SYS_BASE + 0x00C)
#define DEV_INFO_06         *(unsigned int*)(SYS_BASE + 0x010)
#define DEV_INFO_26         *(unsigned int*)(SYS_BASE + 0x014)
#define DEV_INFO_00         *(unsigned int*)(SYS_BASE + 0x018)
#define DEV_INFO_01         *(unsigned int*)(SYS_BASE + 0x01C)
#define DEV_INFO_02         *(unsigned int*)(SYS_BASE + 0x020)
#define DEV_INFO_03         *(unsigned int*)(SYS_BASE + 0x024)
#define DEV_INFO_04         *(unsigned int*)(SYS_BASE + 0x028)
#define DEV_INFO_05         *(unsigned int*)(SYS_BASE + 0x02C)
#define DEV_INFO_11         ((DEV_INFO_24>>0) & 0xFFF)
#define DEV_INFO_12         ((DEV_INFO_24>>12) & 0xFFF)
#define DEV_INFO_10         ((DEV_INFO_24>>24) & 0x3F)
#define DEV_INFO_09         ((DEV_INFO_25>>0) & 0xFFFFFF)
#define DEV_INFO_07         ((DEV_INFO_25>>24) & 0x1F)
#define DEV_INFO_08         ((DEV_INFO_25>>29) & 0x7)
#define DEV_INFO_13         ((DEV_INFO_26>>0) & 0x1F)
#define DEV_INFO_14         ((DEV_INFO_26>>5) & 0x1)
#define DEV_INFO_15         ((DEV_INFO_26>>6) & 0x7FF)
#define DEV_INFO_16         ((DEV_INFO_26>>17) & 0x3FFF)
#define KEY_BASE            0x01C12000
#define DEV_INFO_17         *(unsigned int*)(KEY_BASE + 0x004)
#define DEV_INFO_18         *(unsigned int*)(KEY_BASE + 0x008)
#define DEV_INFO_19         ((DEV_INFO_17>>8) & 0x1F)
#define DEV_INFO_20         *(unsigned int*)(0x11700008)
#define DEV_INFO_21         *(unsigned int*)(0x1170000C)
#define DEV_INFO_22         *(unsigned int*)(0xFFFD0008)
#define DEV_INFO_23         *(unsigned int*)(0xFFFD000C)
#define BOOTCFG		        *(unsigned int*)(SYS_BASE + 0x020)  //BOOTCFG

#define	PLLC0_BASE_ADDRESS 0x01C11000
#define	PLLC1_BASE_ADDRESS 0x01E1A000
#define PLLCTL_OFFSET	0x100
#define OCSEL_OFFSET	0x104
#define PLLM_OFFSET		0x110
#define PREDIV_OFFSET	0x114
#define PLLDIV1_OFFSET	0x118
#define PLLDIV2_OFFSET	0x11C
#define PLLDIV3_OFFSET	0x120
#define OSCDIV_OFFSET	0x124
#define POSTDIV_OFFSET	0x128
#define PLLDIV4_OFFSET	0x160
#define PLLDIV5_OFFSET	0x164
#define PLLDIV6_OFFSET	0x168
#define PLLDIV7_OFFSET	0x16C

#define CFGCHIP3 *(unsigned int*)(0x01C14188)

menuitem "Diagnostics" 
hotmenu Run_All()
{
    GEL_MapOff( );
	Print_Device_Info();
	Print_ROM_Info();
	Print_PLL_Configuration();
	Print_PSC_Status();
}


menuitem "Diagnostics" 
hotmenu Print_ROM_Info()
{
    int errorCode;    
    int boot_config;
    int revision2, revision1, revision0; 
    int arm_dsp;
	int rom_id;
	unsigned int BLCfgStruct;

    GEL_TextOut("---------------------------------------------\n",,,,);
    GEL_TextOut("|               BOOTROM Info                |\n",,,,);
    GEL_TextOut("---------------------------------------------\n",,,,);
    
	arm_dsp = ((ARM_ROM_ID & 0xFF) == 0x6B) ? 1 : 0;

	rom_id = (arm_dsp) ? ARM_ROM_ID : DSP_ROM_ID;

	revision0 = ((rom_id & 0xFF000000) >>24) - 48;    
	revision1 = ((rom_id & 0xFF0000) >>16) - 48;    
	revision2 = ((rom_id & 0xFF00) >>8) - 48;    

    GEL_TextOut("ROM ID: d800k%d%d%d \n",,,,, revision2, revision1, revision0);

	if(revision0 == 1) GEL_TextOut("Silicon Revision 1.0\n",,,,);
	else if(revision0 == 2) GEL_TextOut("Silicon Revision 1.0\n",,,,);
	else if(revision0 == 3) GEL_TextOut("Silicon Revision 2.0\n",,,,);	
	else if(revision0 == 4) GEL_TextOut("Silicon Revision 1.1\n",,,,);
	else if(revision0 == 5) GEL_TextOut("Silicon Revision 2.1\n",,,,);	
	else if(revision0 == 6) GEL_TextOut("Silicon Revision 2.0\n",,,,);
	else if(revision0 == 8) GEL_TextOut("Silicon Revision 2.1\n",,,,);
	else GEL_TextOut("Silicon Revision UNKNOWN\n",,,,);

	
	boot_config = BOOTCFG;
 	GEL_TextOut("Boot pins: %d\n",,,,, boot_config);
	if((revision0 % 2) == 1) {
		if((boot_config & 0x87) == 0x01) GEL_TextOut("Boot Mode: NOR (%x)\n",,,,,boot_config);
		else if((boot_config & 0x87) == 0x02) GEL_TextOut("Boot Mode: HPI (%x)\n",,,,,boot_config);
		else if((boot_config & 0x87) == 0x05) GEL_TextOut("Boot Mode: SPI0 Flash (%x)\n",,,,,boot_config);
		else if((boot_config & 0x87) == 0x06) GEL_TextOut("Boot Mode: SPI1 Flash (%x)\n",,,,,boot_config);
		else if((boot_config & 0x87) == 0x07) GEL_TextOut("Boot Mode: NAND 8 (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x80) GEL_TextOut("Boot Mode: NAND 16 (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x00) GEL_TextOut("Boot Mode: I2C0 Master (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x08) GEL_TextOut("Boot Mode: I2C0 Slave (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x03) GEL_TextOut("Boot Mode: I2C1 Master (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x0B) GEL_TextOut("Boot Mode: I2C1 Slave (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x04) GEL_TextOut("Boot Mode: SPI0 EEPROM (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x0C) GEL_TextOut("Boot Mode: SPI1 EEPROM (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x81) GEL_TextOut("Boot Mode: SPI0 Slave (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x89) GEL_TextOut("Boot Mode: SPI1 Slave (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x83) GEL_TextOut("Boot Mode: UART0 (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x8B) GEL_TextOut("Boot Mode: UART1 (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x82) GEL_TextOut("Boot Mode: UART2 (%x)\n",,,,,boot_config);
		else if((boot_config & 0x8F) == 0x87) GEL_TextOut("Boot Mode: Emulation Debug (%x)\n",,,,,boot_config);
		else GEL_TextOut("Boot Mode: INVALID (%x)\n",,,,,boot_config);
	}
	else{
		if(boot_config == 0x02) GEL_TextOut("Boot Mode: NOR\n",,,,);
		else if(boot_config == 0x0E) GEL_TextOut("Boot Mode: NAND 8\n",,,,);
		else if(boot_config == 0x10) GEL_TextOut("Boot Mode: NAND 16\n",,,,);		
		else if(boot_config == 0x00) GEL_TextOut("Boot Mode: I2C0 EEPROM\n",,,,);
		else if(boot_config == 0x06) GEL_TextOut("Boot Mode: I2C1 EEPROM\n",,,,);
		else if(boot_config == 0x01) GEL_TextOut("Boot Mode: I2C0 Slave\n",,,,);
		else if(boot_config == 0x07) GEL_TextOut("Boot Mode: I2C1 Slave\n",,,,);
		else if(boot_config == 0x08) GEL_TextOut("Boot Mode: SPI0 EEPROM\n",,,,);
		else if(boot_config == 0x09) GEL_TextOut("Boot Mode: SPI1 EEPROM\n",,,,);
		else if(boot_config == 0x0A) GEL_TextOut("Boot Mode: SPI0 Flash\n",,,,);
		else if(boot_config == 0x0C) GEL_TextOut("Boot Mode: SPI1 Flash\n",,,,);
		else if(boot_config == 0x12) GEL_TextOut("Boot Mode: SPI0 Slave\n",,,,);
		else if(boot_config == 0x13) GEL_TextOut("Boot Mode: SPI1 Slave\n",,,,);
		else if((boot_config & 0x3F) == 0x1C) GEL_TextOut("Boot Mode: SDMMC0\n",,,,);
		else if((boot_config & 0x3F) == 0x3C) GEL_TextOut("Boot Mode: SDMMC0, MMC mode\n",,,,);
		else if((boot_config & 0x1F) == 0x16) GEL_TextOut("Boot Mode: UART0\n",,,,);
		else if((boot_config & 0x1F) == 0x17) GEL_TextOut("Boot Mode: UART1\n",,,,);
		else if((boot_config & 0x1F) == 0x14) GEL_TextOut("Boot Mode: UART2\n",,,,);
		else if(boot_config == 0x04) GEL_TextOut("Boot Mode: HPI\n",,,,);
		else if(boot_config == 0x1E) GEL_TextOut("Boot Mode: Emulation Debug\n",,,,);
		else if(boot_config == 0x1C && revision0 > 6) GEL_TextOut("Boot Mode: MMCSD0\n",,,,);
		else GEL_TextOut("Boot Mode: INVALID (%x)\n",,,,,boot_config);
		
		if((boot_config & 0x1F) == 0x16 || (boot_config & 0x1F) == 0x17 || (boot_config & 0x1F) == 0x14) {
			if(((boot_config & 0xE0) >> 5) == 0) GEL_TextOut("24 MHz or 12 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 1) GEL_TextOut("27 MHz or 13.5 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 2) GEL_TextOut("30 MHz or 15 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 3) GEL_TextOut("16.8 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 4) GEL_TextOut("19.2 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 5) GEL_TextOut("24.576 MHz or 12.288 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 6) GEL_TextOut("25 MHz input clock\n",,,,);
			if(((boot_config & 0xE0) >> 5) == 7) GEL_TextOut("26 MHz or 13 MHz input clock\n",,,,);
			
		}
	}
	
	if((revision0 % 2) == 1) {
		BLCfgStruct = arm_dsp ? ARM_BLCfgStruct : DSP_BLCfgStruct;
	}
	else {
		BLCfgStruct = arm_dsp ? ARM_BLCfgStruct : DSP_BLCfgStruct;
	}

	errorCode = (BLCfgStruct >> 8) & 0xFF;    
    GEL_TextOut("ROM Status Code: %x\n",,,,, errorCode);

		if(revision0 == 1) {
			if(errorCode == 0) GEL_TextOut("No error\n",,,,);
			else if(errorCode == 1) GEL_TextOut("Unknown error\n",,,,);
			else if(errorCode == 2) GEL_TextOut("Invalid (or no action) boot mode\n",,,,);
			else if(errorCode == 3) GEL_TextOut("Function not allowed\n",,,,);
			else if(errorCode == 4) GEL_TextOut("This code should not execute\n",,,,);
			else if(errorCode == 5) GEL_TextOut("Waiting to get reset\n",,,,);
			else if(errorCode == 6) GEL_TextOut("Invalid bits for device\n",,,,);
			else if(errorCode == 7) GEL_TextOut("Invalid device type\n",,,,);
			else if(errorCode == 8) GEL_TextOut("Invalid device number\n",,,,);
			else if(errorCode == 9) GEL_TextOut("Invalid address range\n",,,,,);
			else if(errorCode == 10) GEL_TextOut("Not supported for non-secure device\n",,,,);
			else if(errorCode == 11) GEL_TextOut("Invalid password\n",,,,);
			else if(errorCode == 12) GEL_TextOut("Not supported for secure device\n",,,,);
			else if(errorCode == 13) GEL_TextOut("Secure ROM checksum failed\n",,,,);
			else if(errorCode == 14) GEL_TextOut("Invalid RPK\n",,,,);
			else if(errorCode == 15) GEL_TextOut("Invalid signature\n",,,,);
			else if(errorCode == 16) GEL_TextOut("Buffer overflow\n",,,,);
			else if(errorCode == 17) GEL_TextOut("Invalid AIS keyword\n",,,,);
			else if(errorCode == 18) GEL_TextOut("Invalid AIS sync opcode\n",,,,);
			else if(errorCode == 19) GEL_TextOut("Error parsing AIS opcode\n",,,,);
			else if(errorCode == 20) GEL_TextOut("Invalid AIS format\n",,,,);
			else if(errorCode == 21) GEL_TextOut("Invalid AIS state\n",,,,);
			else if(errorCode == 22) GEL_TextOut("Invalid type in AIS boot table command\n",,,,);
			else if(errorCode == 23) GEL_TextOut("Invalid type in AIS section fill command\n",,,,);
			else if(errorCode == 24) GEL_TextOut("Invalid function index\n",,,,);
			else if(errorCode == 25) GEL_TextOut("Invalid argument count\n",,,,);
			else if(errorCode == 26) GEL_TextOut("Too many CRC errors\n",,,,);
			else if(errorCode == 27) GEL_TextOut("Invalid NOR configuration word\n",,,,);
			else if(errorCode == 28) GEL_TextOut("SPI bit error\n",,,,);
			else if(errorCode == 29) GEL_TextOut("Invalid character received by UART\n",,,,);
			else if(errorCode == 30) GEL_TextOut("UART Overrun Error\n",,,,);
			else if(errorCode == 31) GEL_TextOut("UART Parity Error\n",,,,);
			else if(errorCode == 32) GEL_TextOut("UART Frame Error\n",,,,);
			else if(errorCode == 33) GEL_TextOut("UART Break Indicator\n",,,,);
			else GEL_TextOut("Error code not recognized\n",,,,);
		}
		else {
			if(errorCode == 0) GEL_TextOut("No error\n",,,,);
			else if(errorCode == 1) GEL_TextOut("DSP was put to sleep\n",,,,);
			else if(errorCode == 2) GEL_TextOut("Unknown error\n",,,,);
			else if(errorCode == 3) GEL_TextOut("One-time Device Init failed\n",,,,);
			else if(errorCode == 4) GEL_TextOut("One-time Device finalize failed\n",,,,);
			else if(errorCode == 5) GEL_TextOut("Peripheral Open Failed\n",,,,);
			else if(errorCode == 6) GEL_TextOut("Peripheral Close Failed\n",,,,);
			else if(errorCode == 7) GEL_TextOut("Invalid (or no action) boot mode\n",,,,);
			else if(errorCode == 8) GEL_TextOut("Invalid peripheral number\n",,,,);
			else if(errorCode == 9) GEL_TextOut("Invalid AIS keyword\n",,,,,);
			else if(errorCode == 10) GEL_TextOut("Invalid AIS sync opcode\n",,,,);
			else if(errorCode == 11) GEL_TextOut("Error parsing AIS opcode\n",,,,);
			else if(errorCode == 12) GEL_TextOut("Invalid AIS state\n",,,,);
			else if(errorCode == 13) GEL_TextOut("Invalid type in AIS boot table command\n",,,,);
			else if(errorCode == 14) GEL_TextOut("Invalid type in AIS section fill command\n",,,,);
			else if(errorCode == 15) GEL_TextOut("Invalid function index\n",,,,);
			else if(errorCode == 16) GEL_TextOut("Invalid argument count\n",,,,);
			else if(errorCode == 17) GEL_TextOut("Function execute command failed\n",,,,);
			else if(errorCode == 18) GEL_TextOut("Too many CRC errors\n",,,,);
			else if(errorCode == 19) GEL_TextOut("Invalid NOR configuration word\n",,,,);
			else if(errorCode == 20) GEL_TextOut("SPI bit error\n",,,,);
			else if(errorCode == 21) GEL_TextOut("Invalid character received by UART\n",,,,);
			else if(errorCode == 22) GEL_TextOut("UART Overrun Error\n",,,,);
			else if(errorCode == 23) GEL_TextOut("UART Parity Error\n",,,,);
			else if(errorCode == 24) GEL_TextOut("UART Frame Error\n",,,,);
			else if(errorCode == 25) GEL_TextOut("UART Break Indicator\n",,,,);
			else if(errorCode == 26) GEL_TextOut("NAND read page failed\n",,,,);
			else if(errorCode == 27) GEL_TextOut("SDMMC read error\n",,,,);
			else if(errorCode == 128+1) GEL_TextOut("Secure key has not been installed\n",,,,);
			else if(errorCode == 128+2) GEL_TextOut("Invalid Boot exit type\n",,,,);
			else if(errorCode == 128+3) GEL_TextOut("Waiting to get reset\n",,,,);
			else if(errorCode == 128+4) GEL_TextOut("Invalid type of device\n",,,,);
			else if(errorCode == 128+5) GEL_TextOut("Invalid address range\n",,,,);
			else if(errorCode == 128+6) GEL_TextOut("Not supported for non-secure device\n",,,,);
			else if(errorCode == 128+7) GEL_TextOut("Invalid password\n",,,,);
			else if(errorCode == 128+8) GEL_TextOut("Not supported for secure device\n",,,,);
			else if(errorCode == 128+9) GEL_TextOut("Secure ROM checksum failed\n",,,,);
			else if(errorCode == 128+10) GEL_TextOut("Invalid RPK\n",,,,);
			else if(errorCode == 128+11) GEL_TextOut("Invalid signature\n",,,,);
			else if(errorCode == 128+12) GEL_TextOut("AIS command not allowed for this device type\n",,,,);
			else if(errorCode == 128+13) GEL_TextOut("Secure Loading failure\n",,,,);
			else if(errorCode == 128+14) GEL_TextOut("Function not allowed\n",,,,);
			else if(errorCode == 128+15) GEL_TextOut("JTAG Read failed\n",,,,);
			else GEL_TextOut("Error code not recognized\n",,,,);
		}
		GEL_TextOut("Program Counter (PC) = %x\n",,,,,PC);
}

menuitem "Diagnostics" 
hotmenu Print_Device_Info()
{
    int j;
    char k = 65;

    GEL_TextOut("---------------------------------------------\n",,,,);
    GEL_TextOut("|             Device Information            |\n",,,,);
    GEL_TextOut("---------------------------------------------\n",,,,);
    GEL_TextOut("DEV_INFO_00 = %x\n",,,,,DEV_INFO_00);
    GEL_TextOut("DEV_INFO_01 = %x\n",,,,,DEV_INFO_01);
    GEL_TextOut("DEV_INFO_02 = %x\n",,,,,DEV_INFO_02);
    GEL_TextOut("DEV_INFO_03 = %x\n",,,,,DEV_INFO_03);
    GEL_TextOut("DEV_INFO_04 = %x\n",,,,,DEV_INFO_04);
    GEL_TextOut("DEV_INFO_05 = %x\n",,,,,DEV_INFO_05);
    GEL_TextOut("DEV_INFO_06 = %x\n",,,,,DEV_INFO_06);
    GEL_TextOut("DEV_INFO_07-DEV_INFO_08-DEV_INFO_09-DEV_INFO_10-DEV_INFO_11-DEV_INFO_12 = %d-%d-%d-%d-%d-%d\n",,,,,DEV_INFO_07,DEV_INFO_08,DEV_INFO_09,DEV_INFO_10,DEV_INFO_11,DEV_INFO_12);
    GEL_TextOut("DEV_INFO_13,DEV_INFO_14,DEV_INFO_15,DEV_INFO_16 = %d,%d,%d,%d\n",,,,,DEV_INFO_13,DEV_INFO_14,DEV_INFO_15,DEV_INFO_16);
    GEL_TextOut("-----\n",,,,);
    GEL_TextOut("DEV_INFO_17 = %x\n",,,,,DEV_INFO_17);
    GEL_TextOut("DEV_INFO_18 = %x\n",,,,,DEV_INFO_18);
    GEL_TextOut("DEV_INFO_19 = %x\n",,,,,DEV_INFO_19);
    GEL_TextOut("-----\n",,,,);
    GEL_TextOut("DEV_INFO_20 = %x\n",,,,,DEV_INFO_20);
    GEL_TextOut("DEV_INFO_21 = %x\n",,,,,DEV_INFO_21);
    GEL_TextOut("DEV_INFO_22 = %x\n",,,,,DEV_INFO_22);
    GEL_TextOut("DEV_INFO_23 = %x\n",,,,,DEV_INFO_23);
    GEL_TextOut("-----\n",,,,);
    GEL_TextOut("DEV_INFO_24 = %x\n",,,,,DEV_INFO_24);
    GEL_TextOut("DEV_INFO_25 = %x\n",,,,,DEV_INFO_25);
    GEL_TextOut("DEV_INFO_06 = %x\n",,,,,DEV_INFO_06);
    GEL_TextOut("DEV_INFO_26 = %x\n",,,,,DEV_INFO_26);
    GEL_TextOut("\n\n",,,,);
}


menuitem "Diagnostics"
hotmenu Print_PLL_Configuration()
{
	// PLL0 registers
	unsigned int pll0_ocsel, pll0_pllm, pll0_prediv, pll0_postdiv;
	unsigned int pll0_plldiv1, pll0_plldiv2, pll0_plldiv3, pll0_plldiv4;
	unsigned int pll0_plldiv5, pll0_plldiv6, pll0_plldiv7, pll0_pllctl;

	// PLL0 clocks
	unsigned int pll0clk_prediv, pll0clk_pllen;
	unsigned int pll0clk_pllout, pll0clk_pllout_postdiv, pll0clk_sysclk1;
	unsigned int pll0clk_sysclk2, pll0clk_sysclk3, pll0clk_sysclk4, pll0clk_sysclk5;
	unsigned int pll0clk_sysclk6, pll0clk_sysclk7;

	// PLL1 registers
	unsigned int pll1_pllctl, pll1_ocsel, pll1_pllm, pll1_postdiv;
	unsigned int pll1_plldiv1, pll1_plldiv2, pll1_plldiv3;

	// PLL1 clocks
	unsigned int pll1clk_pllout, pll1clk_pllout_postdiv, pll1clk_pllen;
	unsigned int pll1clk_sysclk1, pll1clk_sysclk2, pll1clk_sysclk3;

	// Device in use
	unsigned int arm_dsp, rom_id, revision0;
	arm_dsp = ((ARM_ROM_ID & 0xFF) == 0x6B) ? 1 : 0;
	rom_id = (arm_dsp) ? ARM_ROM_ID : DSP_ROM_ID;
	revision0 = ((rom_id & 0xFF000000) >>24) - 48;    

	/***** Calculate PLL1 clock values first since PLL1 can be input to PLL0 */

	if ((revision0%2) == 0) //PLL1 exists only on OMAP-L138 and pin-for-pin compatible
	{
		pll1_pllctl = *(unsigned int*)(PLLC1_BASE_ADDRESS + PLLCTL_OFFSET);
		pll1_pllm = *(unsigned int*)(PLLC1_BASE_ADDRESS + PLLM_OFFSET);
		pll1_postdiv = *(unsigned int*)(PLLC1_BASE_ADDRESS + POSTDIV_OFFSET);
		pll1_plldiv1 = *(unsigned int*)(PLLC1_BASE_ADDRESS + PLLDIV1_OFFSET);
		pll1_plldiv2 = *(unsigned int*)(PLLC1_BASE_ADDRESS + PLLDIV2_OFFSET);
		pll1_plldiv3 = *(unsigned int*)(PLLC1_BASE_ADDRESS + PLLDIV3_OFFSET);
	
		pll1clk_pllout = OSCIN_FREQ * ((pll1_pllm & 0x1F) + 1);
	
		if ((pll1_postdiv & 0x8000) == 0x8000)
		{
			pll1clk_pllout_postdiv = pll1clk_pllout / ((pll1_postdiv & 0x1F) + 1);
		}
		else
		{
			pll1clk_pllout_postdiv = pll1clk_pllout;
		}
		
		if ((pll1_pllctl & 1) == 1)
		{
			pll1clk_pllen = pll1clk_pllout_postdiv;
		}
		else
		{
			pll1clk_pllen = OSCIN_FREQ;
		}
		
		if ((pll1_plldiv1 & 0x8000) == 0x8000)
		{
			pll1clk_sysclk1 = pll1clk_pllen / ((pll1_plldiv1 & 0x1F) + 1);
		}	
		else
		{
			pll1clk_sysclk1 = pll1clk_pllen;
		}
			
		if ((pll1_plldiv2 & 0x8000) == 0x8000)
		{
			pll1clk_sysclk2 = pll1clk_pllen / ((pll1_plldiv2 & 0x1F) + 1);
		}	
		else
		{
			pll1clk_sysclk2 = pll1clk_pllen;
		}
	
		if ((pll1_plldiv3 & 0x8000) == 0x8000)
		{
			pll1clk_sysclk3 = pll1clk_pllen / ((pll1_plldiv3 & 0x1F) + 1);
		}	
		else
		{
			pll1clk_sysclk3 = pll1clk_pllen;
		}
	}
	
	/***** Calculate PLL0 clock values *****/
	
	pll0_pllctl = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLCTL_OFFSET);
	pll0_prediv = *(unsigned int*)(PLLC0_BASE_ADDRESS + PREDIV_OFFSET);
	pll0_pllm = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLM_OFFSET);
	pll0_postdiv = *(unsigned int*)(PLLC0_BASE_ADDRESS + POSTDIV_OFFSET);
	pll0_plldiv1 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV1_OFFSET);
	pll0_plldiv2 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV2_OFFSET);
	pll0_plldiv3 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV3_OFFSET);
	pll0_plldiv4 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV4_OFFSET);
	pll0_plldiv5 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV5_OFFSET);
	pll0_plldiv6 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV6_OFFSET);
	pll0_plldiv7 = *(unsigned int*)(PLLC0_BASE_ADDRESS + PLLDIV7_OFFSET);

	if ((pll0_prediv & 0x8000) == 0x8000)
	{
		pll0clk_prediv = OSCIN_FREQ / ((pll0_prediv & 0x1F) + 1);
	}
	else
	{
		pll0clk_prediv = OSCIN_FREQ;
	}
	
	pll0clk_pllout = pll0clk_prediv * ((pll0_pllm & 0x1F) + 1);

	if ((pll0_postdiv & 0x8000) == 0x8000)
	{
		pll0clk_pllout_postdiv = pll0clk_pllout / ((pll0_postdiv & 0x1F) + 1);
	}
	else
	{
		pll0clk_pllout_postdiv = pll0clk_pllout;
	}
	
	// Check PLLCTL[PLLEN]
	if ((pll0_pllctl & 1) == 1)
	{
		pll0clk_pllen = pll0clk_pllout_postdiv;
	}
	else
	{
		// Check PLLCTL[EXTCLKSRC]
		if ( (pll0_pllctl & (1<<9)) == (1<<9) )
		{
			pll0clk_pllen = pll1clk_sysclk3;
		}
		else
		{
			pll0clk_pllen = OSCIN_FREQ;
		}
	}
	
	if ((pll0_plldiv1 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk1 = pll0clk_pllen / ((pll0_plldiv1 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk1 = pll0clk_pllen;
	}
		
	if ((pll0_plldiv2 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk2 = pll0clk_pllen / ((pll0_plldiv2 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk2 = pll0clk_pllen;
	}

	if ((pll0_plldiv3 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk3 = pll0clk_pllen / ((pll0_plldiv3 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk3 = pll0clk_pllen;
	}
		
	if ((pll0_plldiv4 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk4 = pll0clk_pllen / ((pll0_plldiv4 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk4 = pll0clk_pllen;
	}
	
	if ((pll0_plldiv5 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk5 = pll0clk_pllen / ((pll0_plldiv5 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk5 = pll0clk_pllen;
	}

	if ((pll0_plldiv6 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk6 = pll0clk_pllen / ((pll0_plldiv6 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk6 = pll0clk_pllen;
	}

	if ((pll0_plldiv7 & 0x8000) == 0x8000)
	{
		pll0clk_sysclk7 = pll0clk_pllen / ((pll0_plldiv7 & 0x1F) + 1);
	}	
	else
	{
		pll0clk_sysclk7 = pll0clk_pllen;
	}

	GEL_TextOut("\n");
	GEL_TextOut("---------------------------------------------\n");
	GEL_TextOut("|              Clock Information             |\n");
	GEL_TextOut("---------------------------------------------\n");	
	GEL_TextOut("\n");

	// if PLLCTL[CLKMODE] == 1
	if ( (pll0_pllctl & (1<<8)) == (1<<8) )
	{
		GEL_TextOut("PLLs configured to utilize 1.2V square wave input.\n");
	}
	else
	{	
		GEL_TextOut("PLLs configured to utilize crystal.\n");
	}

	// if CFGCHIP3[ASYNC3_CLKSRC] == 1
	if ( (CFGCHIP3 & (1<<4)) == 0 )
	{
		GEL_TextOut("ASYNC3 = PLL0_SYSCLK2\n");
	}
	else
	{	
		GEL_TextOut("ASYNC3 = PLL1_SYSCLK2\n");
	}
	
	GEL_TextOut("\n");
	GEL_TextOut("NOTE:  All clock frequencies in following PLL sections are based\n");	
	GEL_TextOut("off OSCIN = %d MHz.  If that value does not match your hardware\n",,,,, OSCIN_FREQ);
	GEL_TextOut("you should change the #define in the top of the gel file, save it,\n");
	GEL_TextOut("and then reload.\n");

	GEL_TextOut("\n");
	GEL_TextOut("---------------------------------------------\n");
	GEL_TextOut("|              PLL0 Information             |\n");
	GEL_TextOut("---------------------------------------------\n");	
	GEL_TextOut("\n");
	
	// Uncomment to see intermediate clock calculations
	//GEL_TextOut("PLL0_PREDIV = %d MHz\n",,,,, pll0clk_prediv);
	//GEL_TextOut("PLL0_PLLOUT = %d MHz\n",,,,, pll0clk_pllout);
	//GEL_TextOut("PLL0_PLLOUT_POSTDIV = %d MHz\n",,,,, pll0clk_pllout_postdiv);
	//GEL_TextOut("PLL0_PLLEN = %d MHz\n",,,,, pll0clk_pllen);
	
	GEL_TextOut("PLL0_SYSCLK1 DSP           = %d MHz\n",,,,, pll0clk_sysclk1);
	GEL_TextOut("PLL0_SYSCLK2 ASYNC3        = %d MHz\n",,,,, pll0clk_sysclk2);
	GEL_TextOut("PLL0_SYSCLK3 EMIFA         = %d MHz\n",,,,, pll0clk_sysclk3);
	GEL_TextOut("PLL0_SYSCLK4               = %d MHz\n",,,,, pll0clk_sysclk4);
	GEL_TextOut("PLL0_SYSCLK5 Not used      = %d MHz\n",,,,, pll0clk_sysclk5);
	GEL_TextOut("PLL0_SYSCLK6 ARM(OMAPL138) = %d MHz\n",,,,, pll0clk_sysclk6);
	GEL_TextOut("PLL0_SYSCLK7 EMAC          = %d MHz\n",,,,, pll0clk_sysclk7);
	
	if ( (pll0clk_sysclk1 / pll0clk_sysclk2) != 2 )
	{
		GEL_TextOut("Error: PLL0_SYSCLK2 must equal PLL0_SYSCLK1 / 2\n");
	}

	if ( (pll0clk_sysclk1 / pll0clk_sysclk4) != 4 )
	{
		GEL_TextOut("Error: PLL0_SYSCLK4 must equal PLL0_SYSCLK1 / 4\n");
	}

	if ( (pll0clk_sysclk1 / pll0clk_sysclk6) != 1 )
	{
		GEL_TextOut("Error: PLL0_SYSCLK6 must equal PLL0_SYSCLK1 / 1\n");
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{
		GEL_TextOut("\n");
		GEL_TextOut("---------------------------------------------\n");
		GEL_TextOut("|              PLL1 Information             |\n");
		GEL_TextOut("---------------------------------------------\n");	
		GEL_TextOut("\n");
		
		// Uncomment to see intermediate clock calculations
		//GEL_TextOut("PLL1_PLLOUT = %d MHz\n",,,,, pll1clk_pllout);
		//GEL_TextOut("PLL1_PLLOUT_POSTDIV = %d MHz\n",,,,, pll1clk_pllout_postdiv);
		//GEL_TextOut("PLL1_PLLEN = %d MHz\n",,,,, pll1clk_pllen);
		
		GEL_TextOut("PLL1_SYSCLK1 DDR2   = %d MHz\n",,,,, pll1clk_sysclk1);
		GEL_TextOut("PLL1_SYSCLK2 ASYNC3 = %d MHz\n",,,,, pll1clk_sysclk2);
		GEL_TextOut("PLL1_SYSCLK3        = %d MHz\n",,,,, pll1clk_sysclk3);
	}
}

menuitem "Diagnostics"
hotmenu Print_PSC_Status()
{
	unsigned int *pPSC0_MDSTAT = (unsigned int*)0x01C10800;
	unsigned int *pPSC1_MDSTAT = (unsigned int*)0x01E27800;
	
	// Device in use
	unsigned int arm_dsp, rom_id, revision0;

	arm_dsp = ((ARM_ROM_ID & 0xFF) == 0x6B) ? 1 : 0;
	rom_id = (arm_dsp) ? ARM_ROM_ID : DSP_ROM_ID;
	revision0 = ((rom_id & 0xFF000000) >>24) - 48; 

	GEL_TextOut("\n");
	GEL_TextOut("---------------------------------------------\n");
	GEL_TextOut("|              PSC0 Information             |\n");
	GEL_TextOut("---------------------------------------------\n");	
	GEL_TextOut("\n");	

	GEL_TextOut("State Decoder:\n");
	GEL_TextOut(" 0 = SwRstDisable (reset asserted, clock off)\n");
	GEL_TextOut(" 1 = SyncReset (reset assered, clock on)\n");
	GEL_TextOut(" 2 = Disable (reset de-asserted, clock off)\n");
	GEL_TextOut(" 3 = Enable (reset de-asserted, clock on)\n");
	GEL_TextOut(">3 = Transition in progress\n");
	GEL_TextOut("\n");		
	
	GEL_TextOut("Module 0:	EDMA3CC (0)        STATE = %d\n",,,,, (pPSC0_MDSTAT[0] & 0x3F));
	GEL_TextOut("Module 1:	EDMA3 TC0          STATE = %d\n",,,,, (pPSC0_MDSTAT[1] & 0x3F));
	GEL_TextOut("Module 2:	EDMA3 TC1          STATE = %d\n",,,,, (pPSC0_MDSTAT[2] & 0x3F));
	GEL_TextOut("Module 3:	EMIFA (BR7)        STATE = %d\n",,,,, (pPSC0_MDSTAT[3] & 0x3F));
	GEL_TextOut("Module 4:	SPI 0              STATE = %d\n",,,,, (pPSC0_MDSTAT[4] & 0x3F));
	GEL_TextOut("Module 5:	MMC/SD 0           STATE = %d\n",,,,, (pPSC0_MDSTAT[5] & 0x3F));
	GEL_TextOut("Module 6:	AINTC              STATE = %d\n",,,,, (pPSC0_MDSTAT[6] & 0x3F));
	GEL_TextOut("Module 7:	ARM RAM/ROM        STATE = %d\n",,,,, (pPSC0_MDSTAT[7] & 0x3F));
	GEL_TextOut("Module 9:	UART 0             STATE = %d\n",,,,, (pPSC0_MDSTAT[9] & 0x3F));
	GEL_TextOut("Module 10:	SCR 0 (BR0/1/2/8)  STATE = %d\n",,,,, (pPSC0_MDSTAT[10] & 0x3F));
	GEL_TextOut("Module 11:	SCR 1 (BR4)        STATE = %d\n",,,,, (pPSC0_MDSTAT[11] & 0x3F));
	GEL_TextOut("Module 12:	SCR 2 (BR3/5/6)    STATE = %d\n",,,,, (pPSC0_MDSTAT[12] & 0x3F));
	GEL_TextOut("Module 13:	PRUSS              STATE = %d\n",,,,, (pPSC0_MDSTAT[13] & 0x3F));
	GEL_TextOut("Module 14:	ARM(OMAPL138)      STATE = %d\n",,,,, (pPSC0_MDSTAT[14] & 0x3F));
	GEL_TextOut("Module 15:	DSP                STATE = %d\n",,,,, (pPSC0_MDSTAT[15] & 0x3F));	
		
	GEL_TextOut("\n");
	GEL_TextOut("---------------------------------------------\n");
	GEL_TextOut("|              PSC1 Information             |\n");
	GEL_TextOut("---------------------------------------------\n");	
	GEL_TextOut("\n");	
	
	GEL_TextOut("State Decoder:\n");
	GEL_TextOut(" 0 = SwRstDisable (reset asserted, clock off)\n");
	GEL_TextOut(" 1 = SyncReset (reset assered, clock on)\n");
	GEL_TextOut(" 2 = Disable (reset de-asserted, clock off)\n");
	GEL_TextOut(" 3 = Enable (reset de-asserted, clock on)\n");
	GEL_TextOut(">3 = Transition in progress\n");
	GEL_TextOut("\n");	
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{
		GEL_TextOut("Module 0:	EDMA3CC (1)        STATE = %d\n",,,,, (pPSC1_MDSTAT[0] & 0x3F));
	}
	
	GEL_TextOut("Module 1:	USB0 (2.0)         STATE = %d\n",,,,, (pPSC1_MDSTAT[1] & 0x3F));
	GEL_TextOut("Module 2:	USB1 (1.1)         STATE = %d\n",,,,, (pPSC1_MDSTAT[2] & 0x3F));
	GEL_TextOut("Module 3:	GPIO               STATE = %d\n",,,,, (pPSC1_MDSTAT[3] & 0x3F));
	GEL_TextOut("Module 4:	UHPI               STATE = %d\n",,,,, (pPSC1_MDSTAT[4] & 0x3F));
	GEL_TextOut("Module 5:	EMAC               STATE = %d\n",,,,, (pPSC1_MDSTAT[5] & 0x3F));
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 6:	DDR2 and SCR F3    STATE = %d\n",,,,, (pPSC1_MDSTAT[6] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 6:	EMIFB (BR20)       STATE = %d\n",,,,, (pPSC1_MDSTAT[6] & 0x3F));
	}

	GEL_TextOut("Module 7:	MCASP0 + FIFO      STATE = %d\n",,,,, (pPSC1_MDSTAT[7] & 0x3F));
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 8:	SATA               STATE = %d\n",,,,, (pPSC1_MDSTAT[8] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 8:	MCASP1 + FIFO      STATE = %d\n",,,,, (pPSC1_MDSTAT[8] & 0x3F));
	}	

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 9:	VPIF               STATE = %d\n",,,,, (pPSC1_MDSTAT[9] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 9:	MCASP2 + FIFO      STATE = %d\n",,,,, (pPSC1_MDSTAT[9] & 0x3F));
	}
	
	GEL_TextOut("Module 10:	SPI 1              STATE = %d\n",,,,, (pPSC1_MDSTAT[10] & 0x3F));
	GEL_TextOut("Module 11:	I2C 1              STATE = %d\n",,,,, (pPSC1_MDSTAT[11] & 0x3F));
	GEL_TextOut("Module 12:	UART 1             STATE = %d\n",,,,, (pPSC1_MDSTAT[12] & 0x3F));
	GEL_TextOut("Module 13:	UART 2             STATE = %d\n",,,,, (pPSC1_MDSTAT[13] & 0x3F));

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 14:	MCBSP0 + FIFO      STATE = %d\n",,,,, (pPSC1_MDSTAT[14] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 15:	MCBSP1 + FIFO      STATE = %d\n",,,,, (pPSC1_MDSTAT[15] & 0x3F));
	}
	
	GEL_TextOut("Module 16:	LCDC               STATE = %d\n",,,,, (pPSC1_MDSTAT[16] & 0x3F));
	GEL_TextOut("Module 17:	eHRPWM (all)       STATE = %d\n",,,,, (pPSC1_MDSTAT[17] & 0x3F));
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 18:	MMC/SD 1           STATE = %d\n",,,,, (pPSC1_MDSTAT[18] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 19:	UPP                STATE = %d\n",,,,, (pPSC1_MDSTAT[19] & 0x3F));
	}

	GEL_TextOut("Module 20:	eCAP (all)         STATE = %d\n",,,,, (pPSC1_MDSTAT[20] & 0x3F));
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 21:	EDMA3 TC2          STATE = %d\n",,,,, (pPSC1_MDSTAT[21] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 21:	eQEP 0/1           STATE = %d\n",,,,, (pPSC1_MDSTAT[21] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 24:	SCR-F0 Br-F0       STATE = %d\n",,,,, (pPSC1_MDSTAT[24] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 24:	SCR8 (Br15)        STATE = %d\n",,,,, (pPSC1_MDSTAT[24] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 25:	SCR-F1 Br-F1       STATE = %d\n",,,,, (pPSC1_MDSTAT[25] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 25:	SCR7 (Br12)        STATE = %d\n",,,,, (pPSC1_MDSTAT[25] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 26:	SCR-F2 Br-F2       STATE = %d\n",,,,, (pPSC1_MDSTAT[26] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 26:	SCR12 (Br18)       STATE = %d\n",,,,, (pPSC1_MDSTAT[26] & 0x3F));
	}
	
	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 27:	SCR-F6 Br-F3       STATE = %d\n",,,,, (pPSC1_MDSTAT[27] & 0x3F));
		GEL_TextOut("Module 28:	SCR-F7 Br-F4       STATE = %d\n",,,,, (pPSC1_MDSTAT[28] & 0x3F));
		GEL_TextOut("Module 29:	SCR-F8 Br-F5       STATE = %d\n",,,,, (pPSC1_MDSTAT[29] & 0x3F));
		GEL_TextOut("Module 30:	Br-F7 (DDR Contr)  STATE = %d\n",,,,, (pPSC1_MDSTAT[30] & 0x3F));
	}

	if ((revision0 % 2) == 0) // OMAP-L138 and pin-for-pin variants only
	{	
		GEL_TextOut("Module 31:	L3 RAM, SCR-F4, Br-F6 STATE = %d\n",,,,, (pPSC1_MDSTAT[31] & 0x3F));
	}
	else
	{	// OMAP-L137 and variants
		GEL_TextOut("Module 31:	L3 RAM (Br13)      STATE = %d\n",,,,, (pPSC1_MDSTAT[31] & 0x3F));
	}
		
}